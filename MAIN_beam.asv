%% PART I - BEAM MODELLING (TEMPLATE)
% Useful commands to initialize script
clear
close all
addpath(genpath(pwd));

%% DATA
% Beam properties
c = 2; % [m]
b = 12; % [m]
y0 = 0.725; % [m]
y1 = 0.4; % [m]
y2 = 1.2; % [m]
h1 = 0.040; % [mm]
h2 = 0.030; % [mm]
h3 = 0.004; % [mm]


% Materials arrays
% Aluminium beam
m(1).INDEX = 1;
m(1).E = 110e9; % Stiffness [Pa] 
m(1).v = 0.33; % Poisson ratio
m(1).G = m(1).E/(2*(1+m(1).v)); % Shear modulus
m(1).rho = 3200; % Density [kg/m^3]
m(1).A = 0.0247; % Section area [m^2]
m(1).mu = m(1).rho*m(1).A; % Linear density
m(1).Iyy = 0.234e-3; % Area inertia [m^4]
m(1).Izz = 3.131e-3; % Area inertia [m^4]
m(1).J = 3.365e-3; % Polar inertia [m^4]
m(1).ky = 0.2621; % Shear correction factor
m(1).kz = 0.2417; % Shear correction factor
m(1).kt = 0.149; % Torsion correction factor
m(1).yc = 0.684; % Shear center [m]
m(1).j_hat = [0,1,0]; % Shear center [m]


%% PREPROCESSING

% Load mesh data
load('beam.mat','xn','Tn','Tm');

% xn : Nodal coordinates       
%      |x1 y1 z1|
%      |x2 y2 z2|
%      |  ...   |
% Tn : Nodal connectivities [Nelem x 2]
% Tm : Material connectivities [Nelem x 1]

% Some variables
[Nnodes,Nel,NDOFs] = GetDiscretization(xn);

% Boundary conditions: Up
Up = SetFixedBoundaryConditions(1, [1,2,3,4,5,6]);

% External forces: Fe, Qe, Be
% Point forces
Feu = SetExternalForcesMomentums(1, Nnodes, 3);
T = SetExternalForcesMomentums(1, Nnodes, 4);
Fe = [Feu;T];

% Body forces
Be = SetGravityBodyForces(xn, Tn, Tm, m, 3);

% Distributed forces
Qe = [];

% Get Idof
for j=1:6
    I_dof(j,1) = 6*(Tn(e,1)-1) + j;
    I_dof(6+j,1) = 6*(Tn(e,2)-1) + j;
end


%% SOLVER

% Build global matrices
[K,M,R,l,Me,Ke]= BeamGlobalMatricesAssembly(xn,Tn,Tm,m);

% Save matrices K and M
save('beam_matrices.mat','K','M'); 

% Load previously computed results
%load('beam_matrices.mat','K','M');

% Compute external forces vector
[f_hat] = BeamGlobalForceVector(xn,Tn,Fe,Be,Qe,R,Me,l);

% Boundary conditions
[u_hat,If,Ip] = BeamBoundaryConditions(xn,Up);

% Solve system
u_hat(If,1) = inv(K(If,If))*(f_hat(If,1)-(K(If,Ip)*u_hat(Ip,1)));
fr = K*u_hat - f_hat;


% Perform modal analysis
% ...





%% POSTPROCESS

% Save data for postprocessing in separate script file (useful when results
% from different runs need to be compared)
save('beam_results.mat');

% Strain and internal forces
for e=1:Nel


    ue = u_hat(I_dof,1);

    % Get each strain component:
    epsilon_a(1,e) = Ba(1,:,e)*R(:,:,e)*ue;
    epsilon_s(:,e) = Bs(:,:,e)*R(:,:,e)*ue;
    epsilon_t(1,e) = Bt(1,:,e)*R(:,:,e)*ue;
    epsilon_b(:,e) = Bb(:,:,e)*R(:,:,e)*ue;

    % Get internal forces and moments at each element node:
    f_int(:,e) = R(:,:,e)*(Ke(:,:,e))*ue;
    Fx(:,e) = (f_int(1,e)-f_int(7,e));
    Fy(:,e) = (f_int(2,e)-f_int(8,e));
    Fz(:,e) = (f_int(3,e)-f_int(9,e));
    Mx(:,e) = (f_int(4,e)-f_int(10,e));
    My(:,e) = (f_int(5,e)-f_int(11,e));
    Mz(:,e) = (f_int(6,e)-f_int(12,e));

end

% Vertical deflection (uz vs x)

for i=1:Nel
x(i)=i*b/Nel;
shear_Fx(i)=u_hat(6*i-5);
shear_Fy(i)=u_hat(6*i-4);    
shear_Fz(i)=u_hat(6*i-3);
bending_Mx(i)=u_hat(6*i-2);
bending_My(i)=u_hat(6*i-1);
bending_Mz(i)=u_hat(6*i);
end

figure(1)
plot(x,shear_Fz);
title("Vertical deflection distribution along the spanwise direction (bending test)",'Interpreter',"latex"); 
xlabel("x[m]",'Interpreter',"latex");
ylabel("$u_z$[m]",'Interpreter',"latex");
grid minor;

figure(2)
plot(x,bending_Mx);
title("Twist angle distribution along the spanwise direction (bending test)",'Interpreter',"latex"); 
xlabel("x[m]",'Interpreter',"latex");
ylabel("$\theta_x$[rad]",'Interpreter',"latex");
grid minor;
